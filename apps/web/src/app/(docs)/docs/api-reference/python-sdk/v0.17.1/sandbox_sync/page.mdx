




## Sandbox

```python
class Sandbox(SandboxSetup, SandboxApi)
```

E2B cloud sandbox gives your agent a full cloud development environment that's sandboxed.

That means:
- Access to Linux OS
- Using filesystem (create, list, and delete files and dirs)
- Run commands
- Sandboxed - you can run any code
- Access to the internet

Check usage docs - https://e2b.dev/docs/sandbox/overview

These cloud sandboxes are meant to be used for agents. Like a sandboxed playgrounds, where the agent can do whatever it wants.

Use the `Sandbox()` to create a new sandbox.

**Example**:

```python
sandbox = Sandbox()
```


#### files

```python
@property
def files() -> Filesystem
```

Filesystem module for interacting with the sandbox's filesystem


#### commands

```python
@property
def commands() -> Process
```

Commands module for interacting with the sandbox's processes


#### pty

```python
@property
def pty() -> Pty
```

PTY module for interacting with the sandbox's pseudo-terminal


#### sandbox\_id

```python
@property
def sandbox_id() -> str
```

Unique identifier of the sandbox


#### envd\_api\_url

```python
@property
def envd_api_url() -> str
```

Get the sandbox API URL


#### connection\_config

```python
@property
def connection_config() -> ConnectionConfig
```

Get the ConnectionConfig object


#### \_\_init\_\_

```python
def __init__(template: Optional[str] = None,
             timeout: Optional[int] = None,
             metadata: Optional[Dict[str, str]] = None,
             envs: Optional[Dict[str, str]] = None,
             api_key: Optional[str] = None,
             domain: Optional[str] = None,
             debug: Optional[bool] = None,
             sandbox_id: Optional[str] = None,
             request_timeout: Optional[float] = None)
```

Instantiate sandbox


#### is\_running

```python
def is_running(request_timeout: Optional[float] = None) -> bool
```

Check if the sandbox is running.

**Returns**:

`True` if the sandbox is running, `False` otherwise
Example
```python
sandbox = Sandbox()
sandbox.is_running() # Returns True

sandbox.kill()
sandbox.is_running() # Returns False
```


#### connect

```python
@classmethod
def connect(cls,
            sandbox_id: str,
            api_key: Optional[str] = None,
            domain: Optional[str] = None,
            debug: Optional[bool] = None)
```

Connects to an existing Sandbox.

**Arguments**:

- `sandbox_id`: Sandbox ID
- `api_key`: E2B API Key
- `domain`: E2B Domain (use only if you self-host E2B)
- `debug`: For developing purposes, uses a local sandbox

**Returns**:

Sandbox object
@example
```python
sandbox = Sandbox()
sandbox_id = sandbox.sandbox_id

same_sandbox = Sandbox.connect(sandbox_id)


#### kill

```python
@class_method_variant("_cls_kill")
def kill(request_timeout: Optional[float] = None) -> bool
```

Kill the sandbox.

**Arguments**:

- `request_timeout`: Timeout for the request

**Returns**:

`True` if the sandbox was killed, `False` if the sandbox was not found


#### set\_timeout

```python
@class_method_variant("_cls_set_timeout")
def set_timeout(timeout: int, request_timeout: Optional[float] = None) -> None
```

Set the sandbox's timeout, after which the sandbox will be automatically killed.

The sandbox can be kept alive for a maximum of 24 hours from the time of creation.
If you try to set the timeout to a period, which exceeds the maximum limit, the timeout will be set to the maximum limit.

**Arguments**:

- `timeout`: Duration in milliseconds. Must be between 0 and 86400000 milliseconds (24 hours).
- `request_timeout`: Timeout for the request




## Process

```python
class Process()
```


#### list

```python
def list(request_timeout: Optional[float] = None) -> List[ProcessInfo]
```

Lists all running processes.

**Arguments**:

- `request_timeout`: Request timeout

**Returns**:

List of running processes


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a process.

**Arguments**:

- `pid`: Process ID to connect to. You can get the list of processes using `sandbox.commands.list()`.
- `request_timeout`: Request timeout

**Returns**:

`True` if the process was killed, `False` if the process was not found


#### send\_stdin

```python
def send_stdin(pid: int, data: str, request_timeout: Optional[float] = None)
```

Sends data to the stdin of a process.

:param pid Process ID to send data to. You can get the list of processes using `sandbox.commands.list()`.
:param data: Data to send to the process
:param request_timeout: Request timeout



#### run

```python
def run(cmd: str,
        background: Union[bool, None] = None,
        envs: Optional[Dict[str, str]] = None,
        user: Username = "user",
        cwd: Optional[str] = None,
        on_stdout: Optional[Callable[[str], None]] = None,
        on_stderr: Optional[Callable[[str], None]] = None,
        timeout: Optional[float] = 60,
        request_timeout: Optional[float] = None)
```

Starts a new process and depending on the `background` parameter, waits for the process to finish or not.

:param cmd Command to execute
:param background:
    If `True`, the function will return a `ProcessHandle` object that can be used to interact with the process.
    If `False`, the function will wait for the process to finish and return a `ProcessResult` object.
:param envs: Environment variables
:param user: User to run the process as
:param cwd: Working directory
:param on_stdout: Callback for stdout
:param on_stderr: Callback for stderr
:param timeout: Timeout for the maximum time the process is allowed to run
:param request_timeout: Timeout for the request
:return: `ProcessHandle` if `background` is `True`, `ProcessResult` if `background` is `False`



#### connect

```python
def connect(pid: int,
            timeout: Optional[float] = 60,
            request_timeout: Optional[float] = None)
```

Connects to an existing process.

**Arguments**:

- `pid`: Process ID to connect to. You can get the list of processes using `sandbox.commands.list()`.
- `timeout`: Timeout for the connection
- `request_timeout`: Request timeout




## Pty

```python
class Pty()
```

Manager for starting and interacting with PTY (pseudo-terminal) processes in the sandbox.


#### kill

```python
def kill(pid: int, request_timeout: Optional[float] = None) -> bool
```

Kills a process.

**Arguments**:

- `pid`: Process ID to kill. You can get the list of processes using `sandbox.commands.list()`.
- `request_timeout`: Timeout for the request

**Returns**:

`true` if the process was killed, `false` if the process was not found


#### send\_stdin

```python
def send_stdin(pid: int,
               data: bytes,
               request_timeout: Optional[float] = None) -> None
```

Sends input to a PTY process.

**Arguments**:

- `pid`: Process ID of the PTY process
- `data`: Input data to send
- `request_timeout`: Timeout for the request


#### create

```python
def create(size: PtySize,
           user: Username = "user",
           cwd: Optional[str] = None,
           envs: Optional[Dict[str, str]] = None,
           timeout: Optional[float] = 60,
           request_timeout: Optional[float] = None) -> ProcessHandle
```

Starts a new process with a PTY (pseudo-terminal).

**Arguments**:

- `size`: Size of the PTY
- `user`: User to start the process as
- `cwd`: Current working directory
- `envs`: Environment variables
- `timeout`: Timeout for the request
- `request_timeout`: Timeout for the request

**Returns**:

New process


#### resize

```python
def resize(pid: int,
           size: PtySize,
           request_timeout: Optional[float] = None) -> None
```

Resizes a PTY process (changes the number of columns and rows in the terminal).

**Arguments**:

- `pid`: Process ID of the PTY process
- `size`: New size of the PTY
- `request_timeout`: Timeout for the request




## ProcessHandle

```python
class ProcessHandle()
```

Class representing a process. It provides methods for waiting and killing the process.
It is also used to iterate over the process output.


#### pid

```python
@property
def pid()
```

Get the process ID.


#### disconnect

```python
def disconnect() -> None
```

Disconnect from the process. It does not kill the process. It only stops receiving events from the process.


#### wait

```python
def wait(on_pty: Optional[Callable[[PtyOutput], None]] = None,
         on_stdout: Optional[Callable[[str], None]] = None,
         on_stderr: Optional[Callable[[str], None]] = None) -> ProcessResult
```

Waits for the process to finish and returns the result.

If the process exits with a non-zero exit code, it throws a `ProcessExitException`.

**Arguments**:

- `on_pty`: Callback for pty output
- `on_stdout`: Callback for stdout output
- `on_stderr`: Callback for stderr output

**Returns**:

Process result


#### kill

```python
def kill() -> bool
```

Kills the process.

**Returns**:

Whether the process was killed successfully




## WatchHandle

```python
class WatchHandle()
```

Handle for watching filesystem events. It is used to iterate over the events in the watched directory.


#### close

```python
def close()
```

Stop watching the directory.

**Warnings**:

  You won't get any event if you don't iterate over the handle before closing it.




## Filesystem

```python
class Filesystem()
```

Manager for interacting with the filesystem in the sandbox.


#### read

```python
def read(path: str,
         format: Literal["text", "bytes", "stream"] = "text",
         user: Username = "user",
         request_timeout: Optional[float] = None)
```

Reads a whole file content and returns it in requested format (text by default).

:param path: Path to the file
:param format: Format of the file content
:param user: Run the operation as this user
:param request_timeout: Timeout for the request
:return File content in requested format



#### write

```python
def write(path: str,
          data: Union[str, bytes, IO],
          user: Username = "user",
          request_timeout: Optional[float] = None) -> EntryInfo
```

Writes content to a file on the path.

When writing to a file that doesn't exist, the file will get created.
When writing to a file that already exists, the file will get overwritten.
When writing to a file that's in a directory that doesn't exist, the directory will get created.

**Arguments**:

- `path`: Path to the file
- `data`: Data to write to the file
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request

**Returns**:

Information about the written file


#### list

```python
def list(path: str,
         user: Username = "user",
         request_timeout: Optional[float] = None) -> List[EntryInfo]
```

Lists entries in a directory.

**Arguments**:

- `path`: Path to the directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request

**Returns**:

List of entries in the directory


#### exists

```python
def exists(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> bool
```

Checks if a file or a directory exists.

:param path: Path to a file or a directory
:param user Run the operation as this user
:param request_timeout Timeout for the request



#### remove

```python
def remove(path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> None
```

Removes a file or a directory.

**Arguments**:

- `path`: Path to a file or a directory
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request


#### rename

```python
def rename(old_path: str,
           new_path: str,
           user: Username = "user",
           request_timeout: Optional[float] = None) -> EntryInfo
```

Renames a file or directory from one path to another.

:param old_path Path to the file or directory to move
:param new_path Path to move the file or directory to
:param user Run the operation as this user
:param request_timeout Timeout for the request

:return: Information about the renamed file or directory



#### make\_dir

```python
def make_dir(path: str,
             user: Username = "user",
             request_timeout: Optional[float] = None) -> bool
```

Creates a new directory and all directories along the way if needed on the specified path.

**Arguments**:

- `path`: Path to a new directory. For example '/dirA/dirB' when creating 'dirB'.
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request

**Returns**:

True if the directory was created, False if the directory already exists


#### watch

```python
def watch(path: str,
          user: Username = "user",
          request_timeout: Optional[float] = None,
          timeout: Optional[float] = 60) -> WatchHandle
```

Watches directory for filesystem events. The watch will be closed after the timeout.

To get the events, you need to iterate over the returned WatchHandle.

**Arguments**:

- `path`: Path to a directory that will be watched
- `user`: Run the operation as this user
- `request_timeout`: Timeout for the request
- `timeout`: Timeout for the watch, after which the watch will be closed

**Returns**:

Watcher handle

