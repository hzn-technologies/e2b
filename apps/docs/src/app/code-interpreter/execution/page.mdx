# Execution explained

The object returned by the `execCell` method is little bit more complex, it's based on Jupyter. Here's an detailed explanation in the [Jupyter documentation](https://jupyter-client.readthedocs.io/en/stable/messaging.html).

It contains the following fields:

- `results`: A list containing result of the cell (interactively interpreted last line) and display calls (e.g. matplotlib plots).
- `logs`: Logs printed to stdout and stderr during execution.
- `error`: An error message, if there was an error during execution of the cell. It works only for Python code, not for system (`!`) commands.

## Result object

There are two main types of results:
- Last line result: The result of the last line of the cell, which is interpreted as the result of the cell. As you would expect in REPL environments.
- Display calls: Calls to display functions, which can be used to display rich output in the notebook.

Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
The result is similar to the structure returned by [ipython kernel](https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics)

The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
as a string, and the result can contain multiple types of data. The text representation is always present, and
the other representations are optional.

The result has those basic data types:

Text types:
- text: text representation of the result, it's always present
- html: html representation of the result
- markdown: markdown representation of the result
- latex: latex representation of the result

Image types:
 - "image/png": "base64 encoded png image",
 - "image/jpeg": "base64 encoded jpeg image",
 - "image/svg+xml": "svg image",

 Other types:
 - "application/json": "json representation",
 - "application/javascript": "javascript representation",
 - "application/pdf": "base64 encoded pdf",
 - "application/geo+json": "geojson

## Logs object

Logs printed to stdout and stderr during execution. Examples of logs are print statements, warnings, subprocess output, etc.

## Error object

An error message, if there was an error during execution of the cell.
<Note>
It works only for Python code, not for system (e.g. `!pip install non_existent_package`) commands. The system commands are executed in a separate process and the output is in stdout/stderr.
</Note>

## Example how to interpret the results to LLM

Here's an example how to return the results to LLM:

<CodeGroup isRunnable={false}>
```js
const code = '<CODE GENERATED BY LLM>'
const execution = await sandbox.notebook.execCell(code)

// There was an error during execution, ruturn the error and its traceback
if (execution.error) {
  return `There was an error during execution: ${execution.error.name}: ${execution.error.value}. Here's the traceback: ${execution.error.traceback}`
}

// The execution has some result, summarize to LLM, what are the results
if (execution.results.length > 0) {
  let message = 'There are results of the cell:\n'
  let counter = 1
  for (const result of execution.results) {
    message += `Result ${counter++}:\n`
    if (result.isMainResult) {
      message += `Main result of the cell is: ${result.text}\n`
    } else {
      message += `Display call: ${result.text}\n`
    }
    message += `It has following formats: ${result.formats()}\n`
  }

  return message
}

// There were no results, check if there was something is stdout/err
if (
  execution.logs.stdout.length > 0 ||
  execution.logs.stderr.length > 0
) {
  let message = 'There are logs during execution:\n'
  if (execution.logs.stdout.length > 0) {
    message += `Stdout: ${execution.logs.stdout.join('\n')}\n`
  }
  if (execution.logs.stderr.length > 0) {
    message += `Stderr: ${execution.logs.stderr.join('\n')}\n`
  }

  return message
}

return 'There was no output of the execution.'
```

```python
code = "<CODE GENERATED BY LLM>"
execution = sandbox.notebook.exec_cell(code)

# There was an error during execution, ruturn the error and its traceback
if execution.error:
  return f"There was an error during execution: {execution.error.name}: {execution.error.value}. Here's the traceback: {execution.error.traceback}"

# The execution has some result, summarize to LLM, what are the results
if execution.results:
    message = "There are results of the cell:\n"
    for i, result in enumerate(execution.results):
        message += f"Result {counter}:\n"
        if result.is_main_result:
            message += f"Main result of the cell is: {result.text}\n"
        else:
            message += f"Display call: {result.text}\n"

        message += f"It has following formats: {result.formats()}\n"

    return message

# There were no results, check if there was something is stdout/err
if execution.logs.stdout or execution.logs.stderr:
  message = "There are logs during execution:\n"
  if execution.logs.stdout:
    message += f"Stdout: {'\n'.join(execution.logs.stdout)}\n"

  if execution.logs.stderr:
    message += f"Stderr: {'\n'.join(execution.logs.stderr)}\n"

    return message

return "There was no output of the execution."
```
</CodeGroup>
