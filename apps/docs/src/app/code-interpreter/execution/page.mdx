# Execution explained

The object returned by the `exec cell` method is little bit more complex, it's based on Jupyter. Here's an detailed explanation in the [Jupyter documentation](https://jupyter-client.readthedocs.io/en/stable/messaging.html).

It contains the following fields:

- `results`: A list containing result of the cell (interactively interpreted last line) and display calls (e.g. matplotlib plots).
- `logs`: Logs printed to stdout and stderr during execution.
- `error`: An error message, if there was an error during execution of the cell. It works only for Python code, not for system (`!` e.g `!pip install e2b`) commands.

## Result object

This object can be created in two different ways:
- Evaluation of the last line: If the last line of the code is an expression, the result is the value of that expression. As you would expect in REPL environments.
- Display calls: Calls to display functions, which can be used to display rich output in the notebook. E.g. [`img.show()`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.show.html), [`display(img)`](https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html), etc.

Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
The result is similar to the structure returned by [ipython kernel](https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics)

The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
as a string, and the result can contain multiple types of data. The text representation is always present, and
the other representations are optional.

The result has those basic data types:

### Text types:
- `text`: text representation of the result, it's always present
- `html`: html representation of the result
- `markdown`: markdown representation of the result
- `latex`: latex representation of the result

### Image types:
 - `png`: "base64 encoded png image",
 - `jpeg`: "base64 encoded jpeg image",
 - `svg`": "svg image",

### Other types:
 - `json`: "json representation",
 - `javascript`: "javascript representation",
 - `pdf`: "base64 encoded pdf"

<Note>
If you want to integrate your own display formats or how to implement them for your classes, you can read more in [here](https://github.com/ipython/ipython/blob/main/examples/IPython%20Kernel/Custom%20Display%20Logic.ipynb)
</Note>

## Logs object

Logs printed to stdout and stderr during execution. Examples of logs are print statements, warnings, subprocess output, etc.

It contains two fields:
- `stdout`: List of strings, each string is a line printed to stdout.
- `stderr`: List of strings, each string is a line printed to stderr.

## Error object

An error message, if there was an error during execution of the cell.
<Note>
It works only for Python code, not for system (e.g. `!pip install non_existent_package`) commands. The system commands are executed in a separate process and the output is in stdout/stderr.
</Note>

It contains three fields:
- `name`: Name of the error, e.g. `NameError`, `ValueError`, etc.
- `value`: Value of the error, e.g. `name 'non_existent_variable' is not defined`, etc.
- `traceback`: Traceback of the error.


## Example how to interpret the results to LLM

Here's an example how to return the results to LLM:

<CodeGroup isRunnable={false}>
```js
const code = '<CODE GENERATED BY LLM>'
const execution = await sandbox.notebook.execCell(code)

// There was an error during execution, ruturn the error and its traceback
if (execution.error) {
  return `There was an error during execution: ${execution.error.name}: ${execution.error.value}. Here's the traceback: ${execution.error.traceback}`
}

// The execution has some result, summarize to LLM, what are the results
if (execution.results.length > 0) {
  let message = 'There are results of the cell:\n'
  let counter = 1
  for (const result of execution.results) {
    message += `Result ${counter++}:\n`
    if (result.isMainResult) {
      message += `Main result of the cell is: ${result.text}\n`
    } else {
      message += `Display call: ${result.text}\n`
    }
    message += `It has following formats: ${result.formats()}\n`
  }

  return message
}

// There were no results, check if there was something is stdout/err
if (
  execution.logs.stdout.length > 0 ||
  execution.logs.stderr.length > 0
) {
  let message = 'There are logs during execution:\n'
  if (execution.logs.stdout.length > 0) {
    message += `Stdout: ${execution.logs.stdout.join('\n')}\n`
  }
  if (execution.logs.stderr.length > 0) {
    message += `Stderr: ${execution.logs.stderr.join('\n')}\n`
  }

  return message
}

return 'There was no output of the execution.'
```

```python
code = "<CODE GENERATED BY LLM>"
execution = sandbox.notebook.exec_cell(code)

# There was an error during execution, ruturn the error and its traceback
if execution.error:
  return f"There was an error during execution: {execution.error.name}: {execution.error.value}. Here's the traceback: {execution.error.traceback}"

# The execution has some result, summarize to LLM, what are the results
if execution.results:
    message = "There are results of the cell:\n"
    for i, result in enumerate(execution.results):
        message += f"Result {counter}:\n"
        if result.is_main_result:
            message += f"Main result of the cell is: {result.text}\n"
        else:
            message += f"Display call: {result.text}\n"

        message += f"It has following formats: {result.formats()}\n"

    return message

# There were no results, check if there was something is stdout/err
if execution.logs.stdout or execution.logs.stderr:
  message = "There are logs during execution:\n"
  if execution.logs.stdout:
    message += f"Stdout: {'\n'.join(execution.logs.stdout)}\n"

  if execution.logs.stderr:
    message += f"Stderr: {'\n'.join(execution.logs.stderr)}\n"

    return message

return "There was no output of the execution."
```
</CodeGroup>
